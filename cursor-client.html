<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>
            * {
                box-sizing: border-box;
            }

            body {
                display: flex;
                gap: 20px;
                padding: 20px;
                margin: 0;
                height: 100vh;
            }

            .client {
                flex: 1;
                position: relative;
                display: flex;
                flex-direction: column;
            }

            .client h3 {
                margin: 0 0 8px 0;
                color: #555;
                font-family: monospace;
            }

            .editor-wrap {
                position: relative;
                flex: 1;
            }

            .editor-wrap textarea {
                width: 100%;
                height: 100%;
                padding: 10px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 16px;
                line-height: 1.5;
                border: 2px solid #ccc;
                border-radius: 4px;
                color: #333;
                outline: none;
                white-space: pre-wrap;
                word-wrap: break-word;
                overflow-y: auto;
                resize: none;
            }

            .editor-wrap textarea:focus {
                border-color: #4CAF50;
            }
        </style>
        <script src="/braid-http-client.js"></script>
        <script src="/simpleton-sync.js"></script>
        <script src="/cursor-highlights.js"></script>
        <script src="/cursor-sync.js"></script>
    </head>
    <body>
        <div class="client" id="client-a">
            <h3></h3>
            <div class="editor-wrap">
                <textarea></textarea>
            </div>
        </div>

        <div class="client" id="client-b">
            <h3></h3>
            <div class="editor-wrap">
                <textarea></textarea>
            </div>
        </div>

        <script>
            var url = "http://127.0.0.1:8888/text/cursor-live-test"

            var colors = ["#e06c75", "#61afef", "#98c379", "#c678dd", "#e5c07b", "#56b6c2"]

            function peer_color(peer_id) {
                var hash = 0
                for (var i = 0; i < peer_id.length; i++)
                    hash = ((hash << 5) - hash + peer_id.charCodeAt(i)) | 0
                return colors[Math.abs(hash) % colors.length]
            }

            function peer_bg_color(peer_id) {
                var c = peer_color(peer_id)
                var r = parseInt(c.slice(1, 3), 16)
                var g = parseInt(c.slice(3, 5), 16)
                var b = parseInt(c.slice(5, 7), 16)
                return `rgba(${r}, ${g}, ${b}, 0.25)`
            }

            async function setup_client(container_id) {
                var container = document.getElementById(container_id)
                var textarea = container.querySelector("textarea")
                var peer = Math.random().toString(36).slice(2)

                container.querySelector("h3").textContent = "peer: " + peer

                var hl = textarea_highlights(textarea)

                var cursors = await cursor_client(url, {
                    peer,
                    get_text: () => textarea.value,
                    on_change: (sels) => {
                        for (var [id, ranges] of Object.entries(sels)) {
                            if (!ranges.length) { hl.remove(id); continue }
                            hl.set(id, ranges.map(r => ({
                                from: r.from, to: r.to,
                                color: r.from === r.to ? peer_color(id) : peer_bg_color(id)
                            })))
                        }
                        hl.render()
                    },
                })

                var applying_remote = false
                var prev_value = textarea.value

                var simpleton = simpleton_client(url, {
                    on_online: (online) => { if (cursors) online ? cursors.online() : cursors.offline() },
                    on_patches: (patches) => {
                        applying_remote = true

                        var sel_start = textarea.selectionStart
                        var sel_end = textarea.selectionEnd

                        for (var p of patches) {
                            var before = textarea.value
                            var del_len = p.range[1] - p.range[0]
                            var ins_len = p.content.length
                            sel_start = transform_pos(sel_start, p.range[0], del_len, ins_len)
                            sel_end = transform_pos(sel_end, p.range[0], del_len, ins_len)
                            textarea.value = before.slice(0, p.range[0])
                                + p.content
                                + before.slice(p.range[1])
                        }

                        textarea.selectionStart = sel_start
                        textarea.selectionEnd = sel_end
                        prev_value = textarea.value

                        if (cursors) cursors.changed(patches)
                        hl.render()

                        // Defer reset so async selectionchange (from setting
                        // textarea.value) doesn't trigger a spurious cursor PUT.
                        setTimeout(() => { applying_remote = false }, 0)
                    },
                    get_state: () => textarea.value,
                    content_type: 'text/plain'
                })

                textarea.oninput = () => {
                    var old_val = prev_value
                    var new_val = textarea.value
                    prev_value = new_val

                    var prefix = 0
                    while (prefix < old_val.length && prefix < new_val.length
                           && old_val[prefix] === new_val[prefix])
                        prefix++

                    var old_suffix = old_val.length
                    var new_suffix = new_val.length
                    while (old_suffix > prefix && new_suffix > prefix
                           && old_val[old_suffix - 1] === new_val[new_suffix - 1]) {
                        old_suffix--
                        new_suffix--
                    }

                    var patch = {
                        range: [prefix, old_suffix],
                        content: new_val.slice(prefix, new_suffix)
                    }

                    if (cursors) {
                        cursors.changed([patch])
                        cursors.set(textarea.selectionStart, textarea.selectionEnd)
                    }
                    simpleton.changed()
                }

                textarea.addEventListener("selectionchange", () => {
                    if (applying_remote || !cursors) return
                    cursors.set(textarea.selectionStart, textarea.selectionEnd)
                })

                hl.render()
                return cursors
            }

            // Local transform_pos for textarea selection adjustment during remote patches
            function transform_pos(pos, del_start, del_len, ins_len) {
                if (del_len === 0) {
                    if (pos < del_start) return pos
                    return pos + ins_len
                }
                if (pos <= del_start) return pos
                if (pos <= del_start + del_len) return del_start + ins_len
                return pos - del_len + ins_len
            }

            var clients = []
            clients.push(setup_client("client-a"))
            clients.push(setup_client("client-b"))

            window.addEventListener("beforeunload", () => {
                clients.forEach(c => c.destroy())
            })
        </script>
    </body>
</html>
